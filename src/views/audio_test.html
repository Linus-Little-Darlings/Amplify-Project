<!doctype html>
<html lang="en">
  <head>
      <title> Swarm </title>

      <style>
        body {margin: 0;}
        canvas {width: 100%; height: 100%;};
      </style>

      <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
      <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
      <script src="https://sdk.scdn.co/spotify-player.js"></script>
      <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>


    </head>

    <body>

      <script>

      // API Requests
      window.onSpotifyWebPlaybackSDKReady = async () => {
        const token = await axios.get('/getSpotifyAuthToken');
        //console.log(token)
        const player = new Spotify.Player({
          name: 'Web Playback SDK Quick Start Player',
          getOAuthToken: cb => { cb(token.data); }
        });

        // Error handling
        player.addListener('initialization_error', ({ message }) => { console.error(message); });
        player.addListener('authentication_error', ({ message }) => { console.error(message); });
        player.addListener('account_error', ({ message }) => { console.error(message); });
        player.addListener('playback_error', ({ message }) => { console.error(message); });

        // Playback status updates
        player.addListener('player_state_changed', state => { console.log(state); });

        // Ready
        player.addListener('ready', ({ device_id }) => {
          console.log('Ready with Device ID', device_id);
        });

        // Not Ready
        player.addListener('not_ready', ({ device_id }) => {
          console.log('Device ID has gone offline', device_id);
        });

        // Connect to the player!
        player.connect();
        checkPlaying();
      };

      async function checkPlaying(){
        console.log('check')
        var track = await axios.get('/currently-playing')
        //console.log('track', track)
        getAnalysis(track.data.item.id)

      }

      async function getAnalysis(id){


          var analysis = await axios.get('/track-analysis', {params: {id: id}})
          console.log('analysis', analysis)


          var sections = analysis.data.sections;


          var renderer, scene, camera, controls, stats, nucleus;

          var WIDTH = window.innerWidth,
            HEIGHT = window.innerHeight,
            FOV = 60,
            NEAR = 1,
            FAR = 1000;

          var electrons = [], numElectrons = 1; // more electrons = slower updating

          // function populateScene() {
          //
          //   //geo.verticesNeedUpdate = true;
          // }


          function updateElectrons(){
            var obj = null;
            for(var i = 0; i < numElectrons; ++i){
                obj = electrons[i]
                obj.position.applyAxisAngle(obj.angle, obj.orbitSpeed);
            }
          }


          function init() {
            document.body.style.backgroundColor = "black";

            renderer = new THREE.WebGLRenderer({
              antialias: true,
              alpha: true
            });
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            document.body.appendChild(renderer.domElement);
            document.body.style.overflow = "hidden";
            document.body.style.margin = "0";
            document.body.style.padding = "0";

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(FOV, WIDTH / HEIGHT, NEAR, FAR);
            camera.position.z = 100;
            scene.add(camera);

            controls = new THREE.TrackballControls(camera, renderer.domElement);
            controls.dynamicDampingFactor = 0.5;
            controls.rotateSpeed = 3;

            var light = new THREE.PointLight(0xffffff, 1, Infinity);
            camera.add(light);

            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0';
            document.body.appendChild(stats.domElement);


            ///////////////////////////////////////////////////////////////////////////////////////////////
            // Populate the scene
            var geo = new THREE.SphereBufferGeometry(1, 16, 16);
            var mat = new THREE.MeshPhongMaterial({color:"blue"});


            var electron = null, plane = new THREE.Plane(), point = new THREE.Vector3();

            geo = new THREE.SphereBufferGeometry(0.75, 16, 16);
            mat = new THREE.MeshPhongMaterial({color:"white"});


            for(var i = 0; i < numElectrons; ++i){
              electron = new THREE.Mesh(geo, mat);
              electrons.push(electron);

              electron.angle = new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize();
              electron.orbitSpeed = 0.025;

              // Reverses direction randomly (half)
              //if(Math.random() > 0.5) electron.orbitSpeed *= -1;

              plane.normal.copy(electron.angle);

              point.set(Math.random(), Math.random(), Math.random());

              plane.projectPoint(point, electron.position);

              electron.position.setLength(30);
              electron.position.applyAxisAngle(electron.angle, 6.28);


              scene.add(electron);
            }



            // Creating KeyframeTracks
            // Starting with orbit speed.

            var times = [];
            var orbit_values = [];
            var color_values = [];
            var i;
            for (i=0; i < sections.length; i++) {
              times[i] = sections[i].start;
              orbit_values[i] = (sections[i].tempo/10);
              color_values[i] = Math.random();    //Red
              color_values[i] = Math.random();    //Green
              color_values[i] = Math.random();    //Blue
            }


            /////////////////////////////////////////////////////////////////////////////////////////


            // console.log('times', times);
            // console.log('values', values);

            // I believe the times of all tracks would need to be the same - maybe not, but shouldn't be an issue regardless

            var orbitSpeedKF = new THREE.NumberKeyframeTrack('.orbitSpeed', times, orbit_values);
            //var colorKF = new THREE.ColorKeyframeTrack('.material.color', times, color_values);



            // Animation Clip creation
            var clip = new THREE.AnimationClip('Action', -1, [orbitSpeedKF]);




            // Animation Mixer creation


            var anim_electron = electrons[0];
            mixer = new THREE.AnimationMixer(anim_electron);

            var clipAction = mixer.clipAction(clip, anim_electron);
            clipAction.play();

            //Use option root option of mixer.clipAction to operate on all electrons in the array
            // var clipAction = null;
            // for(i = 0; i < numElectrons; ++i){
            //     anim_electron = electrons[i]
            //     clipAction = mixer.clipAction(clip, anim_electron);
            //     clipAction.play();
            // }




            resize();
            window.onresize = resize;

            //populateScene();


            clock = new THREE.Clock()



          }



          function animate() {
            requestAnimationFrame(animate);
            updateElectrons();
            render();
            controls.update();
            stats.update();
            renderer.render(scene, camera);
          }


          function helper_sectionAnimation(volume, tempo){
            var particle = null;

            for(var i = 0; i < numElectrons; ++i){
                particle = electrons[i]
                particle.orbitSpeed = (tempo/20);
                particle.orbitSpeed *= -1;
                particle.position.setLength(-volume);
            }
          }


          function resize() {
            WIDTH = window.innerWidth;
            HEIGHT = window.innerHeight;
            if (renderer && camera && controls) {
              renderer.setSize(WIDTH, HEIGHT);
              camera.aspect = WIDTH / HEIGHT;
              camera.updateProjectionMatrix();
              controls.handleResize();
            }
          }

          function render() {
            renderer.render(scene, camera);
            var delta = clock.getDelta();

    				if ( mixer ) {
    					mixer.update( delta );
            }
          }


          function threeReady() {
            init();
            animate();
          }

          (function() {
            function addScript(url, callback) {
              callback = callback || function() {};
              var script = document.createElement("script");
              script.addEventListener("load", callback);
              script.setAttribute("src", url);
              document.head.appendChild(script);
            }

            addScript("https://threejs.org/build/three.js", function() {
              addScript("https://threejs.org/examples/js/controls/TrackballControls.js", function() {
                addScript("https://threejs.org/examples/js/libs/stats.min.js", function() {
                  threeReady();
                })
              })
            })
          })();

        }









      </script>
</html>
