<!doctype html>
<html lang="en">
  <head>
      <title> Swarm </title>

      <style>
        body {margin: 0;}
        canvas {width: 100%; height: 100%;};
      </style>

      <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
      <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
      <script src="https://sdk.scdn.co/spotify-player.js"></script>
      <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>


    </head>

    <body>

      <script>

      // API Requests
      window.onSpotifyWebPlaybackSDKReady = async () => {
        const token = await axios.get('/getSpotifyAuthToken');
        //console.log(token)
        const player = new Spotify.Player({
          name: 'Web Playback SDK Quick Start Player',
          getOAuthToken: cb => { cb(token.data); }
        });

        // Error handling
        player.addListener('initialization_error', ({ message }) => { console.error(message); });
        player.addListener('authentication_error', ({ message }) => { console.error(message); });
        player.addListener('account_error', ({ message }) => { console.error(message); });
        player.addListener('playback_error', ({ message }) => { console.error(message); });

        // Playback status updates
        player.addListener('player_state_changed', state => { console.log(state); });

        // Ready
        player.addListener('ready', ({ device_id }) => {
          console.log('Ready with Device ID', device_id);
        });

        // Not Ready
        player.addListener('not_ready', ({ device_id }) => {
          console.log('Device ID has gone offline', device_id);
        });

        // Connect to the player!
        player.connect();
        checkPlaying();
      };

      async function checkPlaying(){
        console.log('check')
        var track = await axios.get('/currently-playing')
        console.log('track', track)
        getAnalysis(track.data.item.id)
      }

      async function getAnalysis(id){
        var analysis = await axios.get('/track-analysis', {params: {id: id}})
        console.log('analysis', analysis)

        var data = analysis.data

        // Sections : Large variations in rythym or timbre
        var sections = data.sections
        var num_of_sections = sections.length

        console.log(sections)
        console.log(num_of_sections)

        // Segments: Small subdivisions of the song
        var segments = data.segments


        // var buildLines = (context, metric, color, height, heightOffset) => {
        //   var scale = context.canvas.width/(metric[metric.length-1].start - metric[0].start)
        //   var pos = 0;
        //   var toggleColor = false;
        //   metric.forEach(b => {
        //     if(toggleColor){
        //       context.fillStyle = 'white'
        //     }else{
        //       context.fillStyle = color
        //     }
        //     var w = b.duration*scale
        //     context.fillRect(pos, heightOffset, w, height)
        //     pos += w
        //     toggleColor = !toggleColor
        //   })
        // }
        // buildLines(ctx, d.sections, 'green', 10, 0)
        // buildLines(ctx, d.bars, 'blue', 10, 10)
        // buildLines(ctx, d.beats, 'red', 10, 20)
        // buildLines(ctx, d.tatums, 'orange', 10, 30)
      }










      var renderer, scene, camera, controls, stats, nucleus;

      var WIDTH = window.innerWidth,
        HEIGHT = window.innerHeight,
        FOV = 60,
        NEAR = 1,
        FAR = 1000;

      var electrons = [], numElectrons = 220; // more electrons = slower updating

      function populateScene() {
        var geo = new THREE.SphereBufferGeometry(1, 16, 16);
        var mat = new THREE.MeshPhongMaterial({color:"blue"});


        var electron = null, plane = new THREE.Plane(), point = new THREE.Vector3();

        geo = new THREE.SphereBufferGeometry(0.75, 16, 16);
        mat = new THREE.MeshPhongMaterial({color:"white"});


        for(var i = 0; i < numElectrons; ++i){
          electron = new THREE.Mesh(geo, mat);
          electrons.push(electron);

          electron.angle = new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize();
          electron.orbitSpeed = 0.025;

          // Reverses direction randomly (half)
          //if(Math.random() > 0.5) electron.orbitSpeed *= -1;

          plane.normal.copy(electron.angle);

          point.set(Math.random(), Math.random(), Math.random());

          plane.projectPoint(point, electron.position);

          electron.position.setLength(30);
          electron.position.applyAxisAngle(electron.angle, 6.28);

          scene.add(electron);
        }
      }

      function updateElectrons(){
        var obj = null;
        for(var i = 0; i < numElectrons; ++i){
            obj = electrons[i]
            obj.position.applyAxisAngle(obj.angle, obj.orbitSpeed);
        }
      }


      function init() {
        document.body.style.backgroundColor = "black";

        renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true
        });
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document.body.appendChild(renderer.domElement);
        document.body.style.overflow = "hidden";
        document.body.style.margin = "0";
        document.body.style.padding = "0";

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(FOV, WIDTH / HEIGHT, NEAR, FAR);
        camera.position.z = 100;
        scene.add(camera);

        controls = new THREE.TrackballControls(camera, renderer.domElement);
        controls.dynamicDampingFactor = 0.5;
        controls.rotateSpeed = 3;

        var light = new THREE.PointLight(0xffffff, 1, Infinity);
        camera.add(light);

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0';
        document.body.appendChild(stats.domElement);

        resize();
        window.onresize = resize;

        populateScene();

        animate();
      }

      function resize() {
        WIDTH = window.innerWidth;
        HEIGHT = window.innerHeight;
        if (renderer && camera && controls) {
          renderer.setSize(WIDTH, HEIGHT);
          camera.aspect = WIDTH / HEIGHT;
          camera.updateProjectionMatrix();
          controls.handleResize();
        }
      }

      function render() {
        renderer.render(scene, camera);
      }

      function animate() {
        requestAnimationFrame(animate);
        updateElectrons();
        render();
        controls.update();
        stats.update();
      }

      function threeReady() {
        init();
      }

      (function() {
        function addScript(url, callback) {
          callback = callback || function() {};
          var script = document.createElement("script");
          script.addEventListener("load", callback);
          script.setAttribute("src", url);
          document.head.appendChild(script);
        }

        addScript("https://threejs.org/build/three.js", function() {
          addScript("https://threejs.org/examples/js/controls/TrackballControls.js", function() {
            addScript("https://threejs.org/examples/js/libs/stats.min.js", function() {
              threeReady();
            })
          })
        })
      })();


      </script>
</html>
