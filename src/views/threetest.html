<!-- <!doctype html>
<html lang="en">
  <head>
      <title> playin </title>

      <style>
        body {margin: 0;}
        canvas {width: 100%; height: 100%;};
      </style>
    </head>

    <body>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/109/three.js"></script>
      <script src='https://threejs.org/examples/js/controls/OrbitControls.js'></script>
      <script type="module">
        // var scene = new THREE.Scene();
        // var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, .1, 1000); //field of view, browser ratio, near clipping plane, far CP
        // var renderer = new THREE.WebGLRenderer();
        //shape
        // var geometry = new THREE.BoxGeometry(1, 1, 1);
        // //material
        // var material = new THREE.MeshBasicMaterial( {color: 0xFFFFFF, wireframe: false} );
        // var cube = new THREE.Mesh(geometry, material);
        //
        // scene.add(cube);
        //
        // camera.position.z = 3;
        // renderer.setSize(window.innerWidth, window.innerHeight);
        // document.body.appendChild(renderer.domElement);
        // var scene = new THREE.Scene();
        // scene.background = new THREE.Color( 0x20252f );
				// sceneOrtho = new THREE.Scene();
        // var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
        //
        // cameraOrtho = new THREE.OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, 1, 10 );
				// cameraOrtho.position.z = 10;
        //
        // var renderer = new THREE.WebGLRenderer();
        // renderer.setSize( window.innerWidth, window.innerHeight );
        // document.body.appendChild( renderer.domElement );
        // var geometry = new THREE.BoxGeometry( 1, 1, 1 );
        // var material = new THREE.MeshStandardMaterial( { color: 0x00ff00 } );
        // var cube = new THREE.Mesh( geometry, material );
        // var light = new THREE.AmbientLight( 0x404040, 0.4); // soft white light
        //
				// var pointLight = new THREE.PointLight( 0xffffff, 0.8 );
				// camera.add( pointLight );
        // scene.add( light );
        // scene.add( cube );
        //
        // camera.position.z = 5;


        //drawing
        // function animate() {
        //   requestAnimationFrame( animate );
        //   cube.rotation.x += 0.01;
        //   cube.rotation.y += 0.01;
        //   renderer.render( scene, camera );
        // }
        // animate();
      import * as THREE from '/resources/three/build/three.module.js';
			import { OrbitControls } from '/resources/three/examples/jsm/controls/OrbitControls.js';
			var camera, scene, renderer;
			var mesh, sprite, texture;
			var cameraOrtho, sceneOrtho;
			var dpr = window.devicePixelRatio;
			var textureSize = 128 * dpr;
			var vector = new THREE.Vector2();
			init();
			animate();
			function init() {
				//
				var width = window.innerWidth;
				var height = window.innerHeight;
				camera = new THREE.PerspectiveCamera( 70, width / height, 1, 1000 );
				camera.position.z = 20;
				cameraOrtho = new THREE.OrthographicCamera( - width / 2, width / 2, height / 2, - height / 2, 1, 10 );
				cameraOrtho.position.z = 10;
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x20252f );
				sceneOrtho = new THREE.Scene();
				//
				var geometry = new THREE.TorusKnotBufferGeometry( 3, 1, 256, 32 );
				var material = new THREE.MeshStandardMaterial( { color: 0x6083c2 } );
				mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );
				//
				var ambientLight = new THREE.AmbientLight( 0xcccccc, 0.4 );
				scene.add( ambientLight );
				var pointLight = new THREE.PointLight( 0xffffff, 0.8 );
				camera.add( pointLight );
				scene.add( camera );
				//
				var data = new Uint8Array( textureSize * textureSize * 3 );
				texture = new THREE.DataTexture( data, textureSize, textureSize, THREE.RGBFormat );
				texture.minFilter = THREE.NearestFilter;
				texture.magFilter = THREE.NearestFilter;
				//
				var spriteMaterial = new THREE.SpriteMaterial( { map: texture } );
				sprite = new THREE.Sprite( spriteMaterial );
				sprite.scale.set( textureSize, textureSize, 1 );
				sceneOrtho.add( sprite );
				updateSpritePosition();
				//
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.autoClear = false;
				document.body.appendChild( renderer.domElement );
				//
				var overlay = document.getElementById( 'overlay' );
				//
				window.addEventListener( 'resize', onWindowResize, false );
			}
			function onWindowResize() {
				var width = window.innerWidth;
				var height = window.innerHeight;
				camera.aspect = width / height;
				camera.updateProjectionMatrix();
				cameraOrtho.left = - width / 2;
				cameraOrtho.right = width / 2;
				cameraOrtho.top = height / 2;
				cameraOrtho.bottom = - height / 2;
				cameraOrtho.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
				updateSpritePosition();
			}
			function updateSpritePosition() {
				var halfWidth = window.innerWidth / 2;
				var halfHeight = window.innerHeight / 2;
				var halfImageWidth = textureSize / 2;
				var halfImageHeight = textureSize / 2;
				sprite.position.set( - halfWidth + halfImageWidth, halfHeight - halfImageHeight, 1 );
			}
			function animate() {
				requestAnimationFrame( animate );
				mesh.rotation.x += 0.005;
				mesh.rotation.y += 0.01;
				renderer.clear();
				renderer.render( scene, camera );
				// calculate start position for copying data

			}



      </script>
</html> -->



<!doctype html>
<html lang="en">
  <head>
      <title> Swarm </title>

      <style>
        body {margin: 0;}
        canvas {width: 100%; height: 100%;};
      </style>

      <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
      <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
      <script src="https://sdk.scdn.co/spotify-player.js"></script>
      <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>


    </head>

    <body>

      <script>
      // API Requests
      window.onSpotifyWebPlaybackSDKReady = async () => {
        const token = await axios.get('/getSpotifyAuthToken');
        console.log("token" + token);
        const player = new Spotify.Player({
          name: 'Web Playback SDK Quick Start Player',
          getOAuthToken: cb => { cb(token.data); }
        });
        // Error handling
        player.addListener('initialization_error', ({ message }) => { console.error(message); });
        player.addListener('authentication_error', ({ message }) => { console.error(message); });
        player.addListener('account_error', ({ message }) => { console.error(message); });
        player.addListener('playback_error', ({ message }) => { console.error(message); });
        // Playback status updates
        player.addListener('player_state_changed', state => { console.log(state); });
        // Ready
        player.addListener('ready', ({ device_id }) => {
          console.log('Ready with Device ID', device_id);
        });
        // Not Ready
        player.addListener('not_ready', ({ device_id }) => {
          console.log('Device ID has gone offline', device_id);
        });
        // Connect to the player!
        player.connect();
        checkPlaying();
      };
      async function checkPlaying(){
        console.log('check')
        var track = await axios.get('/currently-playing')
        console.log('track', track)
        getData(track.data.item.id)
      }
      async function getData(id){
        var analysis = await axios.get('/track-analysis', {params: {id: id}})
        console.log('analysis', analysis)
        var features = await axios.get('/track-features', {params: {id: id}})
        console.log('features', features)
        var songAnalysis = analysis.data;
        var songFeatures = features.data;

        var sections = songAnalysis.sections;
          var renderer, scene, camera, controls, stats, nucleus, objColor, backColor;
          var WIDTH = window.innerWidth,
            HEIGHT = window.innerHeight,
            FOV = 60,
            NEAR = 1,
            FAR = 1000;
          var electrons = [], numElectrons = 3; // more electrons = slower updating
          // function populateScene() {
          //
          //   //geo.verticesNeedUpdate = true;
          // }
          function updateElectrons(){
            var obj = null;
            for(var i = 0; i < numElectrons; ++i){
                obj = electrons[i]
                obj.position.applyAxisAngle(obj.angle, obj.orbitSpeed);
            }
          }

          function setColorFamily()
          {
            if(songFeatures.energy >= .7 && songFeatures.valence > .6) { //orange - high energy and valence
              backColor = '0xed9e4f';
            }
            else if(songFeatures.energy >= .7 && (songFeatures.valence >= .4 && songFeatures.valence <= .6)) { //blue - high energy but mids valence
              backColor = '0x4bb8dd';
            }
            else if(songFeatures.valence <= .4 && songFeatures.energy > .5) { //deep pink - high energy and low valence
              backColor = '0xb73e8f';
            }
            else if((songFeatures.energy >= .4 && songFeatures.energy <= .6) && (songFeatures.valence >= .4 && songFeatures.valence <= .6)) {//light pink - mids valence and energy
              backColor = '0xcc87ba';
            }
            else if((songFeatures.energy >= .4 && songFeatures.energy <= .6) && songFeatures.valence > .6) { //mids energy and high valence
              backColor = '0x62b6bf';
            }
            else if (songFeatures.valence < .4 && songFeatures.energy < .5) { //purple - low energy and valence
              backColor = '0xb36fc9';
            }
            else { //in case I missed something
              backColor = '0xd2f9e5';
            }
            if(songFeatures.valence >= .6 && (songFeatures.danceability > .5 && songFeatures.danceability < .8)) { //yellow - happy stuff
              objColor = '0xfcc732';
            }
            // else if (songFeatures.valence < .4) {
            //
            // }
            if(songFeatures.acousticness > .8 && songFeatures.energy < .5) { //dark purple - acoustic and slow
              objColor = '0x711593';
            }

          }

          function init() {
            document.body.style.backgroundColor = "black";
            renderer = new THREE.WebGLRenderer({
              antialias: true,
              alpha: true
            });
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            document.body.style.overflow = "hidden";
            document.body.style.margin = "0";
            document.body.style.padding = "0";
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(FOV, WIDTH / HEIGHT, NEAR, FAR);
            camera.position.z = 100;
            scene.add(camera);
            controls = new THREE.TrackballControls(camera, renderer.domElement);
            controls.dynamicDampingFactor = 0.5;
            controls.rotateSpeed = 10;
            var light = new THREE.PointLight(0xffffff, 1, Infinity);
            camera.add(light);
            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0';
            document.body.appendChild(stats.domElement);
            ///////////////////////////////////////////////////////////////////////////////////////////////
            // Populate the scene
            var geo = new THREE.SphereBufferGeometry(1, 16, 16);
            var mat = new THREE.MeshStandardMaterial();
            var electron = null, plane = new THREE.Plane(), point = new THREE.Vector3();
            geo = new THREE.SphereBufferGeometry(2, 16, 16);
            mat = new THREE.MeshStandardMaterial();
            for(var i = 0; i < numElectrons; ++i){
              radius = Math.random() * (5 - .5) + .5;
              geo = new THREE.SphereBufferGeometry(radius, 16, 16);
              electron = new THREE.Mesh(geo, mat);
              electrons.push(electron);
              electron.angle = new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize();
              electron.orbitSpeed = 0.025;
              // Reverses direction randomly (half)
              //if(Math.random() > 0.5) electron.orbitSpeed *= -1;
              plane.normal.copy(electron.angle);
              point.set(Math.random(), Math.random(), Math.random());
              plane.projectPoint(point, electron.position);
              electron.position.setLength(30);
              electron.position.applyAxisAngle(electron.angle, 6.28);
              scene.add(electron);
            }
            /////////////////////////////////////////////////////////////////////////////////////////
            // This is where dynamic animation is coming into play
            // Creating KeyframeTracks
            // Starting with orbit speed.
            var times = [];
            var orbit_values = [];
            var color_values = [sections.length];
            var i;
            for (i=0; i < sections.length; i++) {
              times[i] = sections[i].start;
              orbit_values[i] = (sections[i].tempo/10);
              // Right now, I'm just creating a random set of values for color. As far as I can tell, they need to be in the [0,1] range of rgb - ie, if we're thinking in typical terms of
              // color, 1 would be 255 and 0 would be 0. The color of each segement will be the additions of three values into the array - the constructor will divide the color ray by
              // the number of time segments I pass it, and each section of that division should have one value between 0 and 1
              // Example: if we had three time segements and we wanted the color to go from red, to green, to blue, our color array would look like this:
              //      [1, 0, 0, 0, 1, 0, 0, 0, 1]
              //      |  red  | greeen |  blue  |
              // So for each particle, you'll add three values to the array.
              //color_values[i] = Math.random();    //Red
              //color_values[i] = Math.random();    //Green
              setColorFamily();
              color_values[i] = 0xaaaaaa;    //Blue
            }
            console.log('times: ' + color_values);
            /////////////////////////////////////////////////////////////////////////////////////////
            // console.log('times', times);
            // console.log('values', values);
            // I believe the times of all tracks would need to be the same - maybe not, but shouldn't be an issue regardless
            var orbitSpeedKF = new THREE.NumberKeyframeTrack('.orbitSpeed', times, orbit_values);
            // Below is a KeyframeTrack - it matches time segments with animation values, basically representing one component of an animation like changing color or changing speed.
            // In the values array (named color_values below) you'll define what you want the animation's value to look like during that time interval.
            // There are different kinds of Keyframe tracks. To change color, you'll use a THREE.ColorKeyframeTrack. The name will be '.material.color', because that is the component
            // of the object you want to change. Then you will pass in an array of the times (already grabbed from the track_analysis above) and your array of color values.
            var colorKF = new THREE.ColorKeyframeTrack('.material.color', times, color_values);
            // Animation Clip creation
            // The AnimationClip takes multiple KeyframeTracks and basically adds them to one object to create and a complex animation.
            // Passing negative value forces AnimationClip to calcuate its duration based on the KeyframeTracks passed.
            // Any KeyframeTrack you want included in the animation should be listed in the KeyframeTrack array in the third argument.
            var clip = new THREE.AnimationClip('Action', -1, [orbitSpeedKF, colorKF]);
            // Animation Mixer creation
            // Currently just animating one electron - due to the way animation works, I can't just use a for loop and apply it to a bunch of objects. Currently working on a fix for that.
            var anim_electron = electrons[0];
            // The Mixer is basically a player for an animation on a specific object - in this case, we're animating the single electron I have in the scene
            mixer = new THREE.AnimationMixer(anim_electron);
            // This creates an AnimationClip and
            var clipAction = mixer.clipAction(clip, anim_electron);
            clipAction.play();
            //Use option root option of mixer.clipAction to operate on all electrons in the array
            // var clipAction = null;
            // for(i = 0; i < numElectrons; ++i){
            //     anim_electron = electrons[i]
            //     clipAction = mixer.clipAction(clip, anim_electron);
            //     clipAction.play();
            // }
            resize();
            window.onresize = resize;
            //populateScene();
            clock = new THREE.Clock()
          }
          function animate() {
            updateElectrons();
            render();
            controls.update();
            stats.update();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
          }
          function helper_sectionAnimation(volume, tempo){
            var particle = null;
            for(var i = 0; i < numElectrons; ++i){
                particle = electrons[i]
                particle.orbitSpeed = (tempo/20);
                particle.orbitSpeed *= -1;
                particle.position.setLength(-volume);
            }
          }
          function resize() {
            WIDTH = window.innerWidth;
            HEIGHT = window.innerHeight;
            if (renderer && camera && controls) {
              renderer.setSize(WIDTH, HEIGHT);
              camera.aspect = WIDTH / HEIGHT;
              camera.updateProjectionMatrix();
              controls.handleResize();
            }
          }
          function render() {
            renderer.render(scene, camera);
            var delta = clock.getDelta();
    				if ( mixer ) {
    					mixer.update( delta );
            }
          }
          function threeReady() {
            init();
            animate();
          }
          (function() {
            function addScript(url, callback) {
              callback = callback || function() {};
              var script = document.createElement("script");
              script.addEventListener("load", callback);
              script.setAttribute("src", url);
              document.head.appendChild(script);
            }
            addScript("https://threejs.org/build/three.js", function() {
              addScript("https://threejs.org/examples/js/controls/TrackballControls.js", function() {
                addScript("https://threejs.org/examples/js/libs/stats.min.js", function() {
                  threeReady();
                })
              })
            })
          })();
        }
      </script>
</html>
